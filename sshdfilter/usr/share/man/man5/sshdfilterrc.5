.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "sshdfilterrc 5"
.TH sshdfilterrc 5 "2007-04-08" "perl v5.8.4" ""
.SH "NAME"
sshdfilterrc \- configuration file for sshd brute force blocker
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBsshd\fR wrapper script that generates \fBiptables\fR \s-1DROP\s0 rules when \fBsshd\fR reports any of i) no identify string sent by client ii) attempted login to a non-existant account iii) mupliple password failures for a valid account. \s-1DROP\s0 rules are added in realtime. There are two install routes, either as an \fBsshd\fR wrapper, in which case \fBsshd\fR messages are read directly by \fBsshdfilter\fR, or as a separate standalone program that parses \fBsshd\fR output via a didicated syslog named pipe.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBsshdfilter\fR blocks the frequent brute force attacks on \fBssh\fR daemons, it does this by directly reading the \fBsshd\fR logging output (or syslog output) and generating \fBiptables\fR rules, the process can be quick enough to block an attack before they get a chance to enter any password at all. The blocking policy is defined by a list of blockrules largely by user name or by the type of user name.
.PP
There are two install routes, the old style \fBsshdfilter\fR starts \fBsshd\fR itself, having started \fBsshd\fR with the \fI\-e\fR and \fI\-D\fR options. The newer style uses a syslog configuration line that writes \fBsshd\fR messages to a dedicated named pipe, normally \fI/var/log/sshd.fifo\fR. Regardless, this means \fBsshdfilter\fR can see events as they happenand act on them as they happen.
.SH "OPTIONS"
.IX Header "OPTIONS"
Configuration is divided into several sections, \s-1OPTIONS\s0 for general options, \s-1USERPOLICY\s0 for user based block rules, \s-1IPPOLICY\s0 for \s-1IP\s0 based block rules and \s-1SSHDLOG\s0 for sshd log message definitions.
.Sh "\s-1SECTION\s0 \s-1OPTIONS\s0"
.IX Subsection "SECTION OPTIONS"
.IP "\fBmaxblocktime\fR=\fI<seconds>\fR" 4
.IX Item "maxblocktime=<seconds>"
How long (seconds) after the last activity from an ip that it can be 
removed from iptables block list. The default is 3600*24*3 (259200) seconds, 
which is 3 days.
.IP "\fBmaxchances\fR=\fI<number of guesses>\fR" 4
.IX Item "maxchances=<number of guesses>"
How many password guesses an existing user can make before going on the 
blocked list. \fBsshdfilter\fR runs with \fBsshd\fR with the \-e \-D options, with
these options, \fBsshd\fR likes to output failure and success messages twice.
So this value needs to be twice what you actually want, defaults to 6, ie,
3 failed passwords.
.IP "\fBfirewalladd\fR=\fI<firewall command run when a drop rule is added>\fR =item \fBfirewalldel\fR=\fI<firewall command run when a drop rule is deleted>\fR" 4
.IX Item "firewalladd=<firewall command run when a drop rule is added> =item firewalldel=<firewall command run when a drop rule is deleted>"
These commands are executed, the following variables are available:
\&\f(CW$ip\fR \- \s-1IP\s0 address of the offending machine.
\&\f(CW$chain\fR \- Chain to add this \s-1IP\s0 to.
\&\f(CW$idx\fR \- the next free ipfw index number (if you are using ipfw).
Typical examples are:
firewalladd='iptables \-A \f(CW$chain\fR \-p tcp \-s \f(CW$ip\fR \-\-dport 22 \-j \s-1DROP\s0'
firewalldel='iptables \-D \f(CW$chain\fR \-p tcp \-s \f(CW$ip\fR \-\-dport 22 \-j \s-1DROP\s0'
or for ipfw:
firewalladd='ipfw add \f(CW$idx\fR drop tcp from \f(CW$ip\fR to any dst-port 22'
firewalldel='ipfw delete \f(CW$idx\fR drop tcp from \f(CW$ip\fR to any dst-port 22'
.IP "\fBchain\fR=\fI<name of iptables chain for sshfilter>\fR" 4
.IX Item "chain=<name of iptables chain for sshfilter>"
Name of iptables chain where sshdfilter will store its rules. If you 
want to run multiple isolated instances of sshdfilter then you will
need to change this, your iptables setup and use the \f(CW\*(C`SSHFILTERRC\*(C'\fR 
environment variable (see \s-1INSTALL\s0). Defaults to \f(CW\*(C`SSHD\*(C'\fR.
.IP "\fBip6toip4\fR=\fI<boolean value>\fR" 4
.IX Item "ip6toip4=<boolean value>"
Convert any IPv6 addresses to IPv4, necessary for iptables, as only
ip6tables knows about IPv6. Setting this option to 0 also enables
calling ip6tables instead of iptables, so you should generally leave it
set to 1. Defaults to 1.
.IP "\fBipfwmin\fR=\fI<index number>\fR" 4
.IX Item "ipfwmin=<index number>"
.PD 0
.IP "\fBipfwmax\fR=\fI<index number>\fR" 4
.IX Item "ipfwmax=<index number>"
.PD
Enable the use of ipfw (for \s-1BSD\s0, Solaris, Mac) instead of iptables.
This pair specify the range of index numbers used by the rules. Pick
a range of numbers that fit into your firewall. Read \s-1INSTALL\s0.ipfw
.IP "\fBmail\fR=\fI<email command sequence>\fR" 4
.IX Item "mail=<email command sequence>"
Email any block events using the given command sequence. sshdfilter runs this 
line with some more details on stdin. Note perl executes this line, so be 
careful with escaping. Using the debug option might be a good idea, as would 
logging debug level syslog events (thats \fI/etc/syslog.conf\fR). Defaults to 
the empty string, but can for example be:
 mail=\*(L"mail \-s \e\*(R"sshdfilter event for \f(CW$ip\fR, \f(CW$event\fR\e\*(L" greg\e@abatis.flint\*(R"
.IP "\fBlogsource\fR=\fI<file name>\fR" 4
.IX Item "logsource=<file name>"
Where the sshd log messages come from, either from \s-1STDIN\s0 (sshd \-e \-D | sshdfilter),
or via syslog, in which case the messages are read from a named pipe and you need to
look at the sshdname and logpid options below.
.IP "\fBlogpid\fR=\fI<sshd pid>\fR" 4
.IX Item "logpid=<sshd pid>"
Assuming standard sshd behaviour, children of sshd (one sshd per
connection) log to syslog directly, so the pid reported by syslog will
change every time. The parent of the reported pid will be constant, and
that is what this value should be. Or, set to <=0, and all sshdname
processes will be interpretted as the same sshd. Can be given on the
command line, sshdfilter logpid=`cat /var/run/sshd.pid`. Normally
set to 0, as you normally don't need this.
.IP "\fBsanitise\fR=\fI<'[^\-a\-zA\-Z0\-9_]'>\fR" 4
.IX Item "sanitise=<'[^-a-zA-Z0-9_]'>"
Any character matching this expression is removed from the username
before matching, to ensure odd characters aren't processed.
If satitisation changes a username, the username is called \s-1DIRTY\s0 and
matches the \s-1DIRTY\s0 pattern below. Normally [^\-a\-zA\-Z0\-9_].
.IP "\fBsshdname\fR=\fI<sshd log name>\fR" 4
.IX Item "sshdname=<sshd log name>"
The name of the sshd process, only needed to identify the sshd process
from a none \s-1STDIN\s0 logsource. See also logpid above, which isn't required
if you have only one sshd daemon process. Normally 'sshd'.
.IP "\fBsshdpath\fR=\fI<path to sshd executable>\fR" 4
.IX Item "sshdpath=<path to sshd executable>"
Where the \f(CW\*(C`sshd\*(C'\fR executable can be found, defaults to \fI/usr/sbin/sshd\fR.
.IP "\fBdebug\fR=\fI<boolean>\fR" 4
.IX Item "debug=<boolean>"
Debugging mode can be enabled by setting debug to 1, this enables a more 
verbose message parser which should help in locating any problems. Defaults
to 0.
.Sh "\s-1SECTION\s0 \s-1USERPOLICY\s0"
.IX Subsection "SECTION USERPOLICY"
.RS 4
Action policy says what happens when different users try to log in. The
right hand side of the = is a regular expression that matches either
usernames or is a special word \s-1DEFAULT\s0, \s-1INVALID\s0, \s-1NOID\s0 or \s-1DIRTY\s0.
.Sp
The format is:
.RE
.IP "[number of failures],[block time] = <regular expression>" 4
.IX Item "[number of failures],[block time] = <regular expression>"
[number of failures] is the maximum number of failures (password or
invalid usernames) before an iptables block rule is created. Here twice
what it should be, 'sshd \-e \-D', likes to output failures and successes
twice. [block time] is how long that block will last. After this time,
the iptables rule will be removed. This is specified as <number>d,
<number>h, <number>m or <number>s, for days, hours, minutes or seconds
respectively.
.Sp
This list is read from top to bottom, the first match wins. But,
\&\s-1DEFAULT\s0 sets the current default values and can be used multiple times
to set the ongoing default values for following lines. \s-1INVALID\s0 works in 
the same way, setting the defaults for future matches against users that
match the given regular expression but are also invalid user names.
Notice the effect is to match the last \s-1DEFAULT\s0 or \s-1INVALID\s0 line.
.Sp
An example policy:
 5,3d = \s-1DEFAULT\s0   # catch all
 0,10d = \s-1DIRTY\s0         # username sanitising was necessary? instant long term block
 0,10d = '^(nobody|test|guest|mythtv)$'   # common brute force names, instant block for 10 days
 6 = '^greg$'        # My username, so give me more chances, block for the default 3 days.
 3 = '^g[reg]{3}$'   # allow 3 guesses of greg, grge, ggre, gger, gerg, gegr,
                     # even if they are invalid usernames.
 2,5d = '^root$'     # allow two guesses of root, block for 5 days.
 ,1h = '^iant$'      # default of 3 guesses, only block for 1 hour.
 3,5d = \s-1DEFAULT\s0   # change defaults from this point on, 3 guesses, block for 5 days.
 3,7d = \s-1INVALID\s0    # Sets the dafault for Invalid user names, three chances, and a 7 day block time.
                  # If any of the below are Invalid and missing a value, this value, not the \s-1DEFAULT\s0
                  # value is used.
 4 =  '^(peter|iant)$' # these two get 4 chances and would be blocked for 7 days.
 , = '^bob$'        # If bob exists, gets 3 chances and is blocked for 5 days, all values based on last default.
                   # If bob is Illegal, gets 3 chances and is blocked for 7 days, values based on last \s-1INVALID\s0.
 1,7d = \s-1INVALID\s0    # Catch all for Invalid usernames, if none of the above matched, these numbers will apply.
 0,10d = \s-1NOID\s0      # Catch all No ssh id events, instant block for 10 days.
.Sp
Keep in mind that an sshd bug will duplicate (or worse) log messages. sshdfilter cannot tell these apart, so you need to account for multiple messages here in the number of failures option. The bug only shows up with the \fBsshd\fR \f(CW\*(C`\-eD\*(C'\fR options, as used when logsource='\s-1STDIN\s0', ie, install route 1, as an sshd wrapper. This table summerises what you will problably see:
.Sp
.Vb 5
\& (Failed valid users)
\& Messages   Event   Comment
\&    2         1     First login failure
\&    2         2     Second login failure
\&    2         3     Third login failure
.Ve
.Sp
.Vb 6
\& (Invalid users)
\& Messages   Event   Comment
\&    4         0     Initial connection, no password offered
\&    2         1     First login failure
\&    2         2     Second login failure
\&    2         3     Third login failure
.Ve
.Sh "\s-1SECTION\s0 \s-1IPPOLICY\s0"
.IX Subsection "SECTION IPPOLICY"
.RS 4
This section lets you specify good networks\e(+\e) and bad networks\e(\-\e), by regular 
expression matching \s-1IP\s0 addresses. This matches the same addresses as reported in 
sshdfilter logs, ie, the same \s-1IP\s0 version as used by your iptables command, which 
will most likely be version 4. No hostname lookup is done, or proper subnet matching.
If you want any of that you need to be using iptables. Note that bad does not mean neutral, a 
connection attempt from a bad network will block that connection, even if the connection 
is successful.
.Sp
An example policy is:
.Sp
.Vb 5
\& \-'^192\e.168\e.7\e.9$'  # drop a test #
\& +'^192\e.168\e.7\e.[0\-9]+$'       # always accept, never block LAN connections
\& +'^192\e.168\e.8\e.[0\-9]+$'       # always accept, never block LAN connections
\& +'^192\e.168\e.0\e.[0\-9]+$'       # always accept, never block LAN connections
\& \-'^207\e.46\e.[0\-9]+.[0\-9]+$'    # Block known evil domain
.Ve
.RE
.Sh "\s-1SECTION\s0 \s-1EMAILPOLICY\s0"
.IX Subsection "SECTION EMAILPOLICY"
.RS 4
When to send emails about block events. + means send email, \- means don't.
Read from top to bottom, the first match is the action. Except \s-1DEFAULT\s0, 
which only matches after none of the others have matched. But for \s-1DEFAULT\s0, \s-1INVALID\s0 and \s-1NOID\s0, the
surrounding '' are required.
.Sp
.Vb 5
\& \-'^peter$'   # If peter ever fails to login, don't email.
\& +DEFAULT     # Email in most circumstances.
\& +'^greg$'    # Email if the user is greg, redundant as this is the default.
\& +INVALID     # Email all invalid users
\& \-NOID        # Don't email if there was no ssh id given.
.Ve
.RE
.Sh "\s-1SECTION\s0 \s-1SSHDLOGS\s0"
.IX Subsection "SECTION SSHDLOGS"
.RS 4
The \s-1SSHDLOG\s0 section maps sshd messages into one of several types, No Id string, Invalid User, Bad password for valid user, and Good password for valid user. Each version of sshd and many distribution use different message formats, so the exact format needs to be user configurable for your distribution/sshd. These are already supplied for quite a few distributions, see the \fIpatterns\fR directory in the installation tree.
.Sp
Each of the above types needs two strings, the first is a regular expression that identifies an \s-1IP\s0 address and (maybe) a user name. Or, just identifies that a connection has been attempted and sshd rejected it (the No Id string message).
The second string is a perl command that puts the identified data items into an array in the correct order.
.Sp
These two pairs of lines add patterns that detect and parse lines starting with 'Invalid user' or 'Failed user', which denote the remote machine tried to login with a non-existant account. But for typos, this would be a good sign of a brute force attempt. The second line of each pair puts the user name and then the \s-1IP\s0 address a result array.
 #msg_invalid='^Illegal user (.*) from ([0\-9a\-fA\-F:\e.]+)'
 #map_invalid='push \f(CW@res\fR,$1;  push \f(CW@res\fR,$2;'
.Sp
.Vb 2
\& msg_invalid='^Failed [^ ]+ for illegal user (.*) from ([0\-9a\-fA\-F:\e.]+) port [0\-9]+ ssh2'
\& map_invalid='push @res,$1;  push @res,$2;'
.Ve
.Sp
Identifies valid users that failed to give the right password. Their user name and \s-1IP\s0 address is placed in the result array.
 msg_failed_valid='^Failed password for (.*) from ([0\-9a\-fA\-F:\e.]+) port [0\-9]+ ssh2'
 map_failed_valid='push \f(CW@res\fR,$1;  push \f(CW@res\fR,$2;'
.Sp
Identifies valid user that did give a corrent password. Their user name and \s-1IP\s0 address is placed in the result array.
 msg_accepted_user='^Accepted [^ ]+ for (.*) from ([0\-9a\-fA\-F:\e.]+) port [0\-9]+ ssh2'
 map_accepted_user='push \f(CW@res\fR,$1;  push \f(CW@res\fR,$2;'
.Sp
Identifies port scans and initial brute force attempts that connect but never say anything. Their \s-1IP\s0 address is placed in the result array.
 msg_no_id_string='^Did not receive identification string from ([0\-9a\-fA\-F:\e.]+)'
 map_no_id_string='push \f(CW@res\fR,$1;'
.Sp
Identifies when the sshd process exited, which lets sshdfilter exit gracefully. The return status is placed in the result array, though sshdfilter currently does nothing with this result.
 msg_quit='^Received signal ([0\-9]+); terminating.'
 map_quit='push \f(CW@res\fR,$1;'
.RE
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
\&\&
.RE
.IP "\fB\s-1SSHDFILTERRC\s0\fR"
.IX Item "SSHDFILTERRC"
By default sshdfilter checks for its configuration file in \fI/etc/sshdfilterrc\fR, 
setting this variable will instead use the given file. This will typically be
used to run multiple instances of sshdfilter, when monitoring multiple ports.
.SH "BUGS"
.IX Header "BUGS"
None known. More likely there are features you don't like.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIsshdfilter\fR\|(1)
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Greg: greg at csc liv ac uk. Would welcome any comments.
.PP
LogWatch script written by Tommo: sshdfilter at gmail com.
.SH "LICENSE"
.IX Header "LICENSE"
This software is released under the terms of the \s-1GNU\s0 GPLv2. 
